plugins {
    kotlin("multiplatform") version "2.2.20"
    kotlin("plugin.serialization") version "2.2.20"
    id("io.kotest") version "6.0.4"
    id("com.google.devtools.ksp") version "2.2.20-2.0.4"
    id("org.jlleitschuh.gradle.ktlint") version "13.1.0"
}

group = "com.ternbusty"
version = "1.0-SNAPSHOT"
val kotestVersion = "6.0.4"

repositories {
    mavenCentral()
}

// Detect if this is a release build
fun isReleaseTask(): Boolean =
    gradle.startParameter.taskNames.any {
        it.contains("Release", ignoreCase = true)
    }

// Provider for generated source directory
val buildConfigDir = layout.buildDirectory.dir("generated/buildconfig")

// Generate BuildConfig.kt with build-time constants
val generateBuildConfig by tasks.registering {
    val isRelease = isReleaseTask()
    val defaultLogLevel = if (isRelease) "INFO" else "DEBUG"

    // Track build type as input to invalidate cache when it changes
    inputs.property("buildType", if (isRelease) "release" else "debug")

    // Declare outputs using Provider to wire task dependencies
    outputs.dir(buildConfigDir)

    doLast {
        val outputDir = buildConfigDir.get().asFile
        outputDir.mkdirs()
        file("${outputDir.path}/BuildConfig.kt").writeText(
            """
            package config

            /**
             * Build configuration constants
             * Auto-generated by Gradle build
             */
            object BuildConfig {
                const val DEFAULT_LOG_LEVEL = "$defaultLogLevel"
            }
            """.trimIndent(),
        )
    }
}

// Build C bootstrap library
val buildBootstrap by tasks.registering(Exec::class) {
    workingDir = file("src/nativeInterop/cinterop/bootstrap")

    // Create build directory
    doFirst {
        file("$workingDir/build").mkdirs()
        file("build/bootstrap").mkdirs()
    }

    // Compile netlink.c
    commandLine(
        "gcc",
        "-c",
        "-fPIC",
        "-Wall",
        "-Wextra",
        "netlink.c",
        "-o",
        "build/netlink.o",
    )

    // Compile bootstrap.c and create static library
    doLast {
        exec {
            workingDir = file("src/nativeInterop/cinterop/bootstrap")
            commandLine(
                "gcc",
                "-c",
                "-fPIC",
                "-Wall",
                "-Wextra",
                "bootstrap.c",
                "-o",
                "build/bootstrap.o",
            )
        }

        // Create static library
        exec {
            workingDir = file("src/nativeInterop/cinterop/bootstrap")
            commandLine(
                "ar",
                "rcs",
                "build/libbootstrap.a",
                "build/netlink.o",
                "build/bootstrap.o",
            )
        }

        // Copy to build/bootstrap for linking
        copy {
            from("src/nativeInterop/cinterop/bootstrap/build/libbootstrap.a")
            into("build/bootstrap")
        }
    }
}

kotlin {
    val hostOs = System.getProperty("os.name")
    val isArm64 = System.getProperty("os.arch") == "aarch64"
    val nativeTarget =
        when {
            hostOs == "Linux" && !isArm64 -> linuxX64()
            else -> throw GradleException("Host OS is not supported in Kotlin/Native.")
        }

    nativeTarget.apply {
        binaries {
            executable {
                entryPoint = "main"
                baseName = "kontainer-runtime"
            }
        }

        compilations.getByName("main").cinterops {
            val libseccomp by creating {}
            val socket by creating {}
            val sched by creating {}
            val closerange by creating {}
            val capability by creating {}
            val bootstrap by creating {}
            val prlimit by creating {}
        }
    }

    sourceSets {
        nativeMain {
            dependencies {
                implementation(libs.kotlinxSerializationJson)
            }
            // Add generated BuildConfig to source set using Provider
            kotlin.srcDir(buildConfigDir)
        }
        nativeTest.dependencies {
            implementation("io.kotest:kotest-assertions-core:$kotestVersion")
            implementation("io.kotest:kotest-framework-engine:$kotestVersion")
        }
    }

    // Ensure BuildConfig is generated before compilation
    targets.withType<org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget> {
        compilations["main"].compileTaskProvider.configure {
            dependsOn(generateBuildConfig)
        }
    }
}

// Ensure ktlint tasks run after generation if they touch generated sources
tasks.withType<org.jlleitschuh.gradle.ktlint.tasks.KtLintCheckTask>().configureEach {
    dependsOn(generateBuildConfig)
}
tasks.withType<org.jlleitschuh.gradle.ktlint.tasks.KtLintFormatTask>().configureEach {
    dependsOn(generateBuildConfig)
}

ktlint {
    version.set("1.7.1")
    verbose.set(true)
    reporters {
        reporter(org.jlleitschuh.gradle.ktlint.reporter.ReporterType.CHECKSTYLE)
    }
    // Exclude all generated sources without using deprecated buildDir getter
    filter {
        val genRoot =
            layout.buildDirectory
                .dir("generated")
                .get()
                .asFile
                .toPath()
        exclude { it.file.toPath().startsWith(genRoot) }
    }
}

// Ensure bootstrap C library is built before cinterop
tasks.named("cinteropBootstrapLinuxX64") {
    dependsOn(buildBootstrap)
}
